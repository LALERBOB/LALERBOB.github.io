<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>To ZJJ - ä¸“å±æ˜Ÿæ²³</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- å¼•å…¥æ›´å…·è®¾è®¡æ„Ÿçš„å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;600&family=Noto+Sans+SC:wght@100;300;500&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background-color: #050505; 
            font-family: 'Montserrat', 'Noto Sans SC', sans-serif;
            color: #fff;
            transition: background 2s ease;
        }

        /* === 1. èƒŒæ™¯ç³»ç»Ÿ === */
        /* å¾…æœºï¼šæ·±é‚ƒå®‡å®™ */
        body.bg-idle { background-image: radial-gradient(circle at 50% 120%, #111, #000); }
        /* 1-3ï¼šæå…‰è‰²è°ƒ */
        body.bg-1 { background-image: radial-gradient(circle at 50% 120%, #052226, #000); }
        body.bg-2 { background-image: radial-gradient(circle at 50% 120%, #05260e, #000); }
        body.bg-3 { background-image: radial-gradient(circle at 50% 120%, #261c05, #000); }

        /* è¡¨ç™½æ—¶åˆ»ï¼šæ¢¦å¹»é©¬å¡é¾™æå…‰ (æ›´æŸ”å’Œã€æ›´ä¸æ»‘) */
        body.love-bg {
            background: linear-gradient(120deg, #a18cd1 0%, #fbc2eb 100%);
            /* å åŠ ä¸€å±‚è½»å¾®çš„æµåŠ¨å…‰æ•ˆ */
            position: relative;
        }
        body.love-bg::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.1), transparent 70%);
            animation: pulseLight 4s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulseLight { 0% { opacity: 0.3; } 100% { opacity: 0.7; } }

        #input_video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        /* === 2. UI é‡æ„ï¼šæè‡´ç®€çº¦é«˜çº§æ„Ÿ === */
        #intro-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.85); /* æ·±è‰²èƒŒæ™¯ï¼Œæ›´æ²‰æµ¸ */
            backdrop-filter: blur(20px); /* å¼ºæ¨¡ç³Š */
            z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s cubic-bezier(0.19, 1, 0.22, 1);
        }

        /* æ ‡é¢˜éƒ¨åˆ† */
        .title-group { text-align: center; margin-bottom: 50px; }
        .title-group h1 {
            font-weight: 100; font-size: 42px; letter-spacing: 12px; margin: 0;
            background: linear-gradient(to right, #fff, #aaa); -webkit-background-clip: text; color: transparent;
            text-transform: uppercase;
        }
        .title-group .sub {
            display: block; margin-top: 15px; font-size: 12px; letter-spacing: 6px; color: rgba(255,255,255,0.4); font-weight: 300;
        }

        /* æç®€åˆ—è¡¨ */
        .instruction-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 30px;
            text-align: center; margin-bottom: 60px;
        }
        .ins-item { display: flex; flex-direction: column; align-items: center; gap: 10px; opacity: 0; animation: fadeUp 0.8s forwards; }
        /* ä¾æ¬¡å»¶è¿Ÿæ˜¾ç¤º */
        .ins-item:nth-child(1) { animation-delay: 0.1s; }
        .ins-item:nth-child(2) { animation-delay: 0.2s; }
        .ins-item:nth-child(3) { animation-delay: 0.3s; }
        .ins-item:nth-child(4) { animation-delay: 0.4s; }
        .ins-item:nth-child(5) { animation-delay: 0.5s; }

        .ins-icon { font-size: 24px; filter: grayscale(100%) brightness(1.5); transition: 0.3s; }
        .ins-text { font-size: 12px; font-weight: 300; letter-spacing: 2px; color: rgba(255,255,255,0.6); text-transform: uppercase; }
        .ins-item:hover .ins-icon { transform: scale(1.2); filter: grayscale(0%); }
        
        /* æœ€åä¸€ä¸ªï¼ˆäº”æŒ‡ï¼‰ç‰¹æ®Šé«˜äº® */
        .ins-item.special .ins-icon { filter: drop-shadow(0 0 8px rgba(255, 100, 150, 0.8)); }
        .ins-item.special .ins-text { color: #ffcae0; font-weight: 500; }

        /* æŒ‰é’®ï¼šæµå…‰æ–‡å­—é£æ ¼ */
        #btn-start-game {
            background: none; border: none; padding: 15px 40px;
            font-size: 14px; letter-spacing: 8px; color: #fff;
            cursor: pointer; position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            transition: 0.4s; font-family: inherit; font-weight: 300;
        }
        #btn-start-game::after {
            content: ''; position: absolute; bottom: -1px; left: 0; width: 0%; height: 1px;
            background: #fff; transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }
        #btn-start-game:hover { color: #fff; letter-spacing: 10px; opacity: 1; }
        #btn-start-game:hover::after { width: 100%; }

        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* å…¨å±æŒ‰é’® & åŠ è½½ */
        #btn-fullscreen {
            position: absolute; top: 30px; right: 30px;
            background: none; border: none; color: rgba(255,255,255,0.4);
            font-size: 20px; cursor: pointer; z-index: 100; transition: 0.3s;
        }
        #btn-fullscreen:hover { color: #fff; transform: scale(1.1); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5); font-size: 12px; letter-spacing: 4px; z-index: 50;
        }

        /* å†æ¥ä¸€æ¬¡æŒ‰é’® */
        #btn-restart {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            padding: 12px 35px; background: rgba(255,255,255,0.9);
            border: none; color: #333;
            font-size: 13px; letter-spacing: 3px; font-weight: 500;
            cursor: pointer; opacity: 0; pointer-events: none; transition: 0.8s; z-index: 200; 
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        #btn-restart.visible { opacity: 1; pointer-events: auto; bottom: 18%; }
        #btn-restart:hover { background: #fff; transform: translateX(-50%) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.2); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-idle">

    <!-- æç®€å¼•å¯¼é¡µ -->
    <div id="intro-screen" style="display:none;">
        <div class="title-group">
            <h1>æŒ‡å°–è·³è·ƒ</h1>
            <span class="sub">INTERACTIVE GESTURE ART</span>
        </div>
        
        <div class="instruction-grid">
            <div class="ins-item">
                <div class="ins-icon">âœŠ</div>
                <div class="ins-text">é‡ç½®</div>
            </div>
            <div class="ins-item">
                <div class="ins-icon">â˜ï¸</div>
                <div class="ins-text">å£¹</div>
            </div>
            <div class="ins-item">
                <div class="ins-icon">âœŒï¸</div>
                <div class="ins-text">è´°</div>
            </div>
            <div class="ins-item">
                <div class="ins-icon">ğŸ¤Ÿ</div>
                <div class="ins-text">å</div>
            </div>
            <div class="ins-item special">
                <div class="ins-icon">ğŸ–ï¸</div>
                <div class="ins-text">æƒŠå–œ</div>
            </div>
        </div>

        <button id="btn-start-game">START JOURNEY</button>
    </div>

    <button id="btn-fullscreen">â›¶</button>
    <div id="loading">LOADING SYSTEM...</div>
    <button id="btn-restart">REPLAY MOMENT</button>
    <video id="input_video" playsinline webkit-playsinline></video>

    <script>
        const CONFIG = {
            particleCount: 7500, // å†æ¬¡å¢åŠ ç²’å­ï¼Œä¿è¯å¤§å­—ä½“çš„å¯†åº¦
            baseSize: 3.5,
            flySpeed: 0.12,
            colors: {
                idle: new THREE.Color(0xaaccff),
                num1: new THREE.Color(0x00ffff),
                num2: new THREE.Color(0x55ffaa),
                num3: new THREE.Color(0xffaa00),
                // é«˜çº§æ„Ÿé…è‰²
                wyc: new THREE.Color(0x66ccff), // çº¯å‡€å¤©è“
                zjj: new THREE.Color(0xffadd2), // æ¨±èŠ±ç²‰
                heart: new THREE.Color(0xff2255) // å®çŸ³çº¢
            }
        };

        let scene, camera, renderer, clock;
        let particles, geometry, material;
        let positions, colors, sizes; 
        
        let targetPositions = []; 
        let targetColors = [];    
        let currentColors = [];   
        let explosionVelocities = []; 
        let particleTypes = []; 

        let loadedFont = null;
        let lastGesture = -1;
        let isGameOver = false;
        let animationPhase = 'morph'; 
        let explosionTime = 0;
        
        let celebrationGroup;
        let dreamOrbs = []; // æ›¿æ¢æ°”çƒä¸ºâ€œæ¢¦å¹»å…‰çƒâ€

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0006); // é›¾æ›´æ·¡ä¸€ç‚¹

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.z = 240; // ç¨å¾®æ‹‰è¿œç›¸æœºï¼Œå› ä¸ºå­—å˜å¤§äº†

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const al = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(al);
            const dl = new THREE.PointLight(0xffffff, 1.5);
            dl.position.set(0, 100, 200);
            scene.add(dl);

            createParticleSystem();
            celebrationGroup = new THREE.Group();
            scene.add(celebrationGroup);

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                loadedFont = font;
                document.getElementById('loading').style.display = 'none';
                document.getElementById('intro-screen').style.display = 'flex';
                setTargetShape('idle');
            });

            document.getElementById('btn-start-game').addEventListener('click', () => {
                document.getElementById('intro-screen').style.opacity = '0';
                setTimeout(() => { document.getElementById('intro-screen').style.display = 'none'; }, 1000);
                startCamera();
            });

            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });
            
            document.getElementById('btn-restart').addEventListener('click', resetGame);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            clock = new THREE.Clock();
            animate();
        }

        function updateBackground(gesture) {
            if (isGameOver) return; 
            document.body.className = ''; 
            switch(gesture) {
                case 1: document.body.classList.add('bg-1'); break;
                case 2: document.body.classList.add('bg-2'); break;
                case 3: document.body.classList.add('bg-3'); break;
                default: document.body.classList.add('bg-idle'); break;
            }
        }

        function triggerLoveMoment() {
            isGameOver = true;
            document.body.className = 'love-bg';
            
            setTargetShape('love'); 
            spawnDreamOrbs(); // è§¦å‘å…‰çƒ
            
            setTimeout(() => {
                document.getElementById('btn-restart').classList.add('visible');
            }, 2500);
        }

        function resetGame() {
            isGameOver = false;
            lastGesture = -1;
            document.body.className = 'bg-idle';
            document.getElementById('btn-restart').classList.remove('visible');
            clearDreamOrbs();
            setTargetShape('idle');
            camera.position.z = 240;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0.4)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // === æ–°å¢ï¼šæŸ”å’Œå…‰æ–‘çº¹ç†ï¼ˆç”¨äºèƒŒæ™¯æ¼‚æµ®ç‰©ï¼‰ ===
        function createSoftBokehTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);
            sizes = new Float32Array(CONFIG.particleCount);
            currentColors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const x = (Math.random() - 0.5) * 800;
                const y = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 300;
                positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;

                currentColors[i*3] = CONFIG.colors.idle.r;
                currentColors[i*3+1] = CONFIG.colors.idle.g;
                currentColors[i*3+2] = CONFIG.colors.idle.b;

                targetPositions.push(new THREE.Vector3(x, y, z));
                targetColors.push(CONFIG.colors.idle);
                explosionVelocities.push(new THREE.Vector3());
                particleTypes.push(0); 

                sizes[i] = CONFIG.baseSize * (0.6 + Math.random());
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            material = new THREE.PointsMaterial({
                size: CONFIG.baseSize,
                map: createGlowTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function sampleGeometryPoints(geom, count) {
            const points = [];
            const pos = geom.attributes.position;
            const faces = pos.count / 3;
            let totalArea = 0;
            const areas = [];
            const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
            
            for(let i=0; i<faces; i++) {
                a.fromBufferAttribute(pos, i*3); b.fromBufferAttribute(pos, i*3+1); c.fromBufferAttribute(pos, i*3+2);
                b.sub(a); c.sub(a); b.cross(c);
                totalArea += 0.5 * b.length();
                areas.push(totalArea);
            }
            
            for(let i=0; i<count; i++) {
                const r = Math.random() * totalArea;
                let faceIdx = areas.findIndex(area => r <= area);
                if (faceIdx === -1) faceIdx = faces - 1;
                
                const r1 = Math.random(); const r2 = Math.random(); const sqrtR1 = Math.sqrt(r1);
                a.fromBufferAttribute(pos, faceIdx*3); b.fromBufferAttribute(pos, faceIdx*3+1); c.fromBufferAttribute(pos, faceIdx*3+2);
                
                const p = new THREE.Vector3();
                p.addScaledVector(a, 1 - sqrtR1); p.addScaledVector(b, sqrtR1 * (1 - r2)); p.addScaledVector(c, sqrtR1 * r2);
                p.z += (Math.random()-0.5) * 8; // å­—ä½“å˜å¾—æ›´æ‰å¹³é”åˆ©
                points.push(p);
            }
            return points;
        }

        function getShapePoints(type) {
            let pts = [];
            let pointColors = [];
            let types = [];
            
            if (type === 'idle') {
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2 * 3; 
                    const radius = 50 + Math.random() * 200;
                    const spiralX = Math.cos(angle) * radius;
                    const spiralY = Math.sin(angle) * radius * 0.6; 
                    pts.push(new THREE.Vector3(spiralX, spiralY, (Math.random()-0.5)*100));
                    pointColors.push(CONFIG.colors.idle);
                    types.push(0);
                }
            } 
            else if (['1', '2', '3'].includes(type)) {
                const geo = new THREE.TextGeometry(type, { font: loadedFont, size: 75, height: 5, curveSegments: 12, bevelEnabled:true, bevelThickness:1, bevelSize:0.5, bevelSegments:2 });
                geo.center();
                pts = sampleGeometryPoints(geo, CONFIG.particleCount);
                const c = CONFIG.colors['num'+type];
                for(let i=0; i<CONFIG.particleCount; i++) { pointColors.push(c); types.push(0); }
            }
            else if (type === 'love') {
                // === æ–‡å­—æ”¾å¤§ & é—´è·æ‹‰å¼€ ===
                const countWYC = Math.floor(CONFIG.particleCount * 0.28);
                const countZJJ = Math.floor(CONFIG.particleCount * 0.28);
                const countHeart = Math.floor(CONFIG.particleCount * 0.35);
                
                // 1. å·¦ä¾§ WYC (åŠ å¤§ size åˆ° 36ï¼Œæ‹‰å¤§é—´è·åˆ° -150)
                const geoLeft = new THREE.TextGeometry("WYC", { font: loadedFont, size: 36, height: 2, curveSegments: 12 });
                geoLeft.center(); geoLeft.translate(-150, 0, 0);
                const ptsLeft = sampleGeometryPoints(geoLeft, countWYC);
                ptsLeft.forEach(p => { pts.push(p); pointColors.push(CONFIG.colors.wyc); types.push(0); });
                
                // 2. å³ä¾§ ZJJ (åŠ å¤§ size åˆ° 36ï¼Œæ‹‰å¤§é—´è·åˆ° 150)
                const geoRight = new THREE.TextGeometry("ZJJ", { font: loadedFont, size: 36, height: 2, curveSegments: 12 });
                geoRight.center(); geoRight.translate(150, 0, 0);
                const ptsRight = sampleGeometryPoints(geoRight, countZJJ);
                ptsRight.forEach(p => { pts.push(p); pointColors.push(CONFIG.colors.zjj); types.push(0); });
                
                // 3. ä¸­é—´çˆ±å¿ƒ
                const heartShape = new THREE.Shape();
                heartShape.moveTo(25, 25);
                heartShape.bezierCurveTo(25, 25, 20, 0, 0, 0);
                heartShape.bezierCurveTo(-30, 0, -30, 35, -30, 35);
                heartShape.bezierCurveTo(-30, 55, -10, 77, 25, 95);
                heartShape.bezierCurveTo(60, 77, 80, 55, 80, 35);
                heartShape.bezierCurveTo(80, 35, 80, 0, 50, 0);
                heartShape.bezierCurveTo(35, 0, 25, 25, 25, 25);
                const geoHeart = new THREE.ExtrudeGeometry(heartShape, { depth: 4, bevelEnabled: true, bevelSegments: 3, steps: 1, bevelSize: 1, bevelThickness: 1 });
                geoHeart.rotateZ(Math.PI); geoHeart.scale(0.65, 0.65, 0.65); geoHeart.center();
                const ptsHeart = sampleGeometryPoints(geoHeart, countHeart);
                ptsHeart.forEach(p => { pts.push(p); pointColors.push(CONFIG.colors.heart); types.push(1); }); 
            }
            
            while(pts.length < CONFIG.particleCount) {
                pts.push(new THREE.Vector3((Math.random()-0.5)*700, (Math.random()-0.5)*400, (Math.random()-0.5)*200));
                pointColors.push(new THREE.Color(0xffffff));
                types.push(0);
            }
            return { pts, pointColors, types };
        }

        function setTargetShape(type) {
            const data = getShapePoints(type);
            const positionsArr = geometry.attributes.position.array;

            for(let i=0; i<CONFIG.particleCount; i++) {
                if (data.pts[i]) targetPositions[i] = data.pts[i];
                if (data.pointColors[i]) targetColors[i] = data.pointColors[i];
                if (data.types) particleTypes[i] = data.types[i];
            }

            if (type === 'love') {
                animationPhase = 'explosion';
                explosionTime = 0;
                for(let i=0; i<CONFIG.particleCount; i++) {
                    positionsArr[i*3] = 0; positionsArr[i*3+1] = 0; positionsArr[i*3+2] = 0;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    const force = 10 + Math.random() * 25; 
                    explosionVelocities[i].set(
                        force * Math.sin(theta) * Math.cos(phi),
                        force * Math.sin(theta) * Math.sin(phi),
                        force * Math.cos(theta)
                    );
                }
            } else {
                animationPhase = 'morph';
            }
        }

        // === 3. æ¢¦å¹»å…‰æ–‘é€»è¾‘ (æ›¿ä»£æ°”çƒ) ===
        function spawnDreamOrbs() {
            if (dreamOrbs.length > 0) return; // é˜²æ­¢é‡å¤
            
            const texture = createSoftBokehTexture();
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0, 
                blending: THREE.AdditiveBlending 
            });

            // æŸ”å’Œé…è‰²
            const colors = [0xffccee, 0xeeccee, 0xccddee, 0xffffff];

            for(let i=0; i<60; i++) {
                const sprite = new THREE.Sprite(material.clone());
                // éšæœºä½ç½®
                sprite.position.set(
                    (Math.random()-0.5) * 500,
                    -250 - Math.random() * 200,
                    (Math.random()-0.5) * 200
                );
                
                // éšæœºå¤§å°
                const scale = 10 + Math.random() * 20;
                sprite.scale.set(scale, scale, 1);
                
                // éšæœºé¢œè‰²
                sprite.material.color.setHex(colors[Math.floor(Math.random()*colors.length)]);
                
                // è‡ªå®šä¹‰åŠ¨ç”»å±æ€§
                sprite.userData = {
                    speed: 0.5 + Math.random() * 0.8, // ä¸Šå‡é€Ÿåº¦
                    swayOffset: Math.random() * Math.PI * 2, // æ‘‡æ‘†ç›¸ä½
                    swaySpeed: 1 + Math.random(), // æ‘‡æ‘†é¢‘ç‡
                    fadeSpeed: 0.01 + Math.random() * 0.02, // é—ªçƒé€Ÿåº¦
                    baseOpacity: 0.3 + Math.random() * 0.4
                };
                
                celebrationGroup.add(sprite);
                dreamOrbs.push(sprite);
            }
        }

        function clearDreamOrbs() {
            dreamOrbs.forEach(b => { celebrationGroup.remove(b); b.material.dispose(); });
            dreamOrbs = [];
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            const positionsArr = geometry.attributes.position.array;
            const colorsArr = geometry.attributes.color.array;

            // ç²’å­é€»è¾‘
            if (animationPhase === 'explosion') {
                explosionTime += delta;
                if (explosionTime < 0.8) {
                    for(let i=0; i<CONFIG.particleCount; i++) {
                        explosionVelocities[i].multiplyScalar(0.93); 
                        positionsArr[i*3] += explosionVelocities[i].x;
                        positionsArr[i*3+1] += explosionVelocities[i].y;
                        positionsArr[i*3+2] += explosionVelocities[i].z;
                        currentColors[i*3] = 1; currentColors[i*3+1] = 1; currentColors[i*3+2] = 1;
                    }
                } else {
                    animationPhase = 'morph';
                }
            } else {
                let heartbeatScale = 1.0;
                if (isGameOver) {
                    const beat = (Math.sin(time * 3) + 1) / 2; 
                    heartbeatScale = 1.0 + beat * 0.1; // å¿ƒè·³å¹…åº¦ç¨å¾®å‡å°ï¼Œå› ä¸ºå­—å¤§äº†
                }

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    let tx = targetPositions[i].x;
                    let ty = targetPositions[i].y;
                    let tz = targetPositions[i].z;

                    if (particleTypes[i] === 1 && isGameOver) {
                        tx *= heartbeatScale; ty *= heartbeatScale; tz *= heartbeatScale;
                    }

                    const speed = isGameOver ? 0.08 : CONFIG.flySpeed; 
                    
                    positionsArr[i*3] += (tx - positionsArr[i*3]) * speed;
                    positionsArr[i*3+1] += (ty - positionsArr[i*3+1]) * speed;
                    positionsArr[i*3+2] += (tz - positionsArr[i*3+2]) * speed;

                    if (!isGameOver) {
                        positionsArr[i*3] += Math.sin(time + i) * 0.05;
                    } else {
                        // è¡¨ç™½æ—¶åˆ»ï¼Œç²’å­å¾®åŠ¨
                        positionsArr[i*3] += Math.sin(time * 1.5 + i) * 0.06;
                        positionsArr[i*3+1] += Math.cos(time * 1.2 + i) * 0.06;
                    }

                    currentColors[i*3] += (targetColors[i].r - currentColors[i*3]) * 0.05;
                    currentColors[i*3+1] += (targetColors[i].g - currentColors[i*3+1]) * 0.05;
                    currentColors[i*3+2] += (targetColors[i].b - currentColors[i*3+2]) * 0.05;
                }
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                colorsArr[i*3] = currentColors[i*3];
                colorsArr[i*3+1] = currentColors[i*3+1];
                colorsArr[i*3+2] = currentColors[i*3+2];
            }

            // === æ¢¦å¹»å…‰çƒåŠ¨ç”» ===
            dreamOrbs.forEach(orb => {
                // ä¸Šå‡
                orb.position.y += orb.userData.speed;
                // ä¸æ»‘æ‘‡æ‘† (Sine wave)
                orb.position.x += Math.sin(time * orb.userData.swaySpeed + orb.userData.swayOffset) * 0.3;
                
                // å‘¼å¸é—ªçƒ
                const alpha = orb.userData.baseOpacity + Math.sin(time * 3 + orb.userData.swayOffset) * 0.15;
                orb.material.opacity = alpha;

                // å¾ªç¯
                if(orb.position.y > 350) {
                    orb.position.y = -250;
                    orb.position.x = (Math.random()-0.5) * 500;
                }
            });

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function startCamera() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
            camera.start();
        }

        function onResults(results) {
            if (isGameOver) return; 

            let gesture = 0;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                gesture = detectGesture(results.multiHandLandmarks[0]);
            }

            if (gesture !== lastGesture) {
                lastGesture = gesture;
                updateBackground(gesture); 

                if (gesture === 0) { setTargetShape('idle'); clearDreamOrbs(); }
                else if (gesture === 1) { setTargetShape('1'); clearDreamOrbs(); }
                else if (gesture === 2) { setTargetShape('2'); clearDreamOrbs(); }
                else if (gesture === 3) { setTargetShape('3'); clearDreamOrbs(); }
                else if (gesture === 5) { 
                    triggerLoveMoment(); 
                }
            }
        }

        function detectGesture(lm) {
            const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
            const i = isUp(8, 6); const m = isUp(12, 10); const r = isUp(16, 14); const p = isUp(20, 18);
            const t = Math.abs(lm[4].x - lm[17].x) > 0.15; 
            let count = 0;
            if(i) count++; if(m) count++; if(r) count++; if(p) count++; if(t) count++;
            if (count >= 4) return 5; 
            if (i && m && r && !p) return 3; 
            if (i && m && t && !p) return 3; 
            if (i && m && !r && !p) return 2; 
            if (i && !m && !r && !p) return 1; 
            return 0; 
        }
    </script>
</body>
</html>
